import { InjectionToken, Injectable, Inject, Optional, ɵɵdefineInjectable, ɵɵinject, Directive, ViewContainerRef, TemplateRef, ComponentFactoryResolver, ChangeDetectorRef, Input, Renderer2, SkipSelf, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { __awaiter } from 'tslib';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/lazy-elements/lazy-elements.tokens.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LAZY_ELEMENT_CONFIGS = new InjectionToken('LAZY_ELEMENT_CONFIGS');
/** @type {?} */
const LAZY_ELEMENT_ROOT_OPTIONS = new InjectionToken('LAZY_ELEMENT_ROOT_OPTIONS');
/** @type {?} */
const LAZY_ELEMENT_ROOT_GUARD = new InjectionToken('LAZY_ELEMENT_ROOT_GUARD');
/** @type {?} */
const LAZY_ELEMENTS_REGISTRY = new InjectionToken('LAZY_ELEMENTS_REGISTRY', {
    providedIn: 'root',
    factory: (/**
     * @return {?}
     */
    () => new Map()),
});
/**
 * @record
 */
function LazyElementsRegistry() { }
if (false) {
    /** @type {?} */
    LazyElementsRegistry.prototype.get;
    /** @type {?} */
    LazyElementsRegistry.prototype.set;
    /** @type {?} */
    LazyElementsRegistry.prototype.has;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/lazy-elements/lazy-elements-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOG_PREFIX = '@angular-extensions/elements';
/**
 * @record
 */
function HooksConfig() { }
if (false) {
    /** @type {?|undefined} */
    HooksConfig.prototype.beforeLoad;
    /** @type {?|undefined} */
    HooksConfig.prototype.afterLoad;
}
/**
 * @record
 */
function ElementConfig() { }
if (false) {
    /** @type {?} */
    ElementConfig.prototype.tag;
    /** @type {?} */
    ElementConfig.prototype.url;
    /** @type {?|undefined} */
    ElementConfig.prototype.isModule;
    /** @type {?|undefined} */
    ElementConfig.prototype.importMap;
    /** @type {?|undefined} */
    ElementConfig.prototype.loadingComponent;
    /** @type {?|undefined} */
    ElementConfig.prototype.errorComponent;
    /** @type {?|undefined} */
    ElementConfig.prototype.preload;
    /** @type {?|undefined} */
    ElementConfig.prototype.hooks;
    /** @type {?|undefined} */
    ElementConfig.prototype.isAdded;
}
class LazyElementsLoaderService {
    /**
     * @param {?} registry
     * @param {?} options
     */
    constructor(registry, options) {
        this.registry = registry;
        this.options = options;
        this.configs = [];
        if (!options) {
            this.options = {};
        }
    }
    /**
     * @param {?} newConfigs
     * @return {?}
     */
    addConfigs(newConfigs) {
        newConfigs.forEach((/**
         * @param {?} newConfig
         * @return {?}
         */
        (newConfig) => {
            /** @type {?} */
            const existingConfig = this.getElementConfig(newConfig.tag);
            if (existingConfig) {
                console.warn(`${LOG_PREFIX} - ElementConfig for tag '${newConfig.tag}' was previously added, it will not be added multiple times, continue...`);
            }
            else {
                newConfig.isAdded = true;
                this.configs.push(newConfig);
                /** @type {?} */
                const shouldPreload = newConfig.preload !== undefined
                    ? newConfig.preload
                    : this.options.preload;
                if (shouldPreload) {
                    this.loadElement(newConfig.url, newConfig.tag, newConfig.isModule, newConfig.importMap, newConfig.hooks);
                }
            }
        }));
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    getElementConfig(tag) {
        return this.configs.find((/**
         * @param {?} config
         * @return {?}
         */
        (config) => config.tag === tag));
    }
    /**
     * @param {?=} tags
     * @return {?}
     */
    preload(tags) {
        /** @type {?} */
        let configs = this.configs;
        if (tags) {
            configs = this.configs.filter((/**
             * @param {?} config
             * @return {?}
             */
            (config) => tags.includes(config.tag)));
        }
        configs.forEach((/**
         * @param {?} config
         * @return {?}
         */
        (config) => this.loadElement(config.url, config.tag, config.isModule, config.importMap, config.hooks)));
    }
    /**
     * @param {?} url
     * @param {?} tag
     * @param {?=} isModule
     * @param {?=} importMap
     * @param {?=} hooksConfig
     * @return {?}
     */
    loadElement(url, tag, isModule, importMap, hooksConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const config = this.getElementConfig(tag);
            isModule !== null && isModule !== void 0 ? isModule : (isModule = (_a = config === null || config === void 0 ? void 0 : config.isModule) !== null && _a !== void 0 ? _a : this.options.isModule);
            importMap !== null && importMap !== void 0 ? importMap : (importMap = (_b = config === null || config === void 0 ? void 0 : config.importMap) !== null && _b !== void 0 ? _b : this.options.importMap);
            if (!tag) {
                throw new Error(`${LOG_PREFIX} - tag for '${url}' not found, the *axLazyElement has to be used on HTML element`);
            }
            if (!url) {
                if (!(config === null || config === void 0 ? void 0 : config.url) && !importMap) {
                    throw new Error(`${LOG_PREFIX} - url for <${tag}> not found`);
                }
                else if (importMap) {
                    url = tag;
                }
                else {
                    url = config.url;
                }
            }
            if (!this.hasElement(url)) {
                /** @type {?} */
                const notifier = this.addElement(url);
                /** @type {?} */
                const beforeLoadHook = (_e = (_c = hooksConfig === null || hooksConfig === void 0 ? void 0 : hooksConfig.beforeLoad) !== null && _c !== void 0 ? _c : (_d = config === null || config === void 0 ? void 0 : config.hooks) === null || _d === void 0 ? void 0 : _d.beforeLoad) !== null && _e !== void 0 ? _e : (_g = (_f = this.options) === null || _f === void 0 ? void 0 : _f.hooks) === null || _g === void 0 ? void 0 : _g.beforeLoad;
                /** @type {?} */
                const afterLoadHook = (_k = (_h = hooksConfig === null || hooksConfig === void 0 ? void 0 : hooksConfig.afterLoad) !== null && _h !== void 0 ? _h : (_j = config === null || config === void 0 ? void 0 : config.hooks) === null || _j === void 0 ? void 0 : _j.afterLoad) !== null && _k !== void 0 ? _k : (_m = (_l = this.options) === null || _l === void 0 ? void 0 : _l.hooks) === null || _m === void 0 ? void 0 : _m.afterLoad;
                if (importMap) {
                    url = yield this.resolveImportMap(url);
                }
                /** @type {?} */
                const script = (/** @type {?} */ (document.createElement('script')));
                if (isModule) {
                    script.type = 'module';
                }
                script.src = url;
                script.onload = (/**
                 * @return {?}
                 */
                () => {
                    if (afterLoadHook) {
                        this.handleHook(afterLoadHook, tag)
                            .then(notifier.resolve)
                            .catch(notifier.reject);
                    }
                    else {
                        notifier.resolve();
                    }
                });
                script.onerror = notifier.reject;
                if (beforeLoadHook) {
                    this.handleHook(beforeLoadHook, tag)
                        .then((/**
                     * @return {?}
                     */
                    () => document.body.appendChild(script)))
                        .catch(notifier.reject);
                }
                else {
                    document.body.appendChild(script);
                }
            }
            return this.registry.get(this.stripUrlProtocol(url));
        });
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    addElement(url) {
        /** @type {?} */
        let notifier;
        this.registry.set(this.stripUrlProtocol(url), new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => (notifier = { resolve, reject }))));
        return notifier;
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    hasElement(url) {
        return this.registry.has(this.stripUrlProtocol(url));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    stripUrlProtocol(url) {
        return url.replace(/https?:\/\//, '');
    }
    /**
     * @private
     * @param {?} hook
     * @param {?} tag
     * @return {?}
     */
    handleHook(hook, tag) {
        try {
            return Promise.resolve(hook(tag));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    resolveImportMap(url) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const System = ((/** @type {?} */ (window))).System;
            if (System) {
                yield System.prepareImport();
                url = System.resolve(url);
            }
            else {
                throw new Error(`${LOG_PREFIX} - importMap feature depends on SystemJS library to be globally loaded but none was found, thus '${url}' can't be resolved. You should either load SystemJS or remove the importMap flag.`);
            }
            return url;
        });
    }
}
LazyElementsLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
LazyElementsLoaderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LAZY_ELEMENTS_REGISTRY,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LAZY_ELEMENT_ROOT_OPTIONS,] }] }
];
/** @nocollapse */ LazyElementsLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function LazyElementsLoaderService_Factory() { return new LazyElementsLoaderService(ɵɵinject(LAZY_ELEMENTS_REGISTRY), ɵɵinject(LAZY_ELEMENT_ROOT_OPTIONS, 8)); }, token: LazyElementsLoaderService, providedIn: "root" });
if (false) {
    /** @type {?} */
    LazyElementsLoaderService.prototype.configs;
    /**
     * @type {?}
     * @private
     */
    LazyElementsLoaderService.prototype.registry;
    /** @type {?} */
    LazyElementsLoaderService.prototype.options;
}
/**
 * @record
 */
function Notifier() { }
if (false) {
    /** @type {?} */
    Notifier.prototype.resolve;
    /** @type {?} */
    Notifier.prototype.reject;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/lazy-elements/lazy-element/lazy-element.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOG_PREFIX$1 = '@angular-extensions/elements';
class LazyElementDirective {
    /**
     * @param {?} vcr
     * @param {?} template
     * @param {?} elementsLoaderService
     * @param {?} cfr
     * @param {?} cdr
     */
    constructor(vcr, template, elementsLoaderService, cfr, cdr) {
        this.vcr = vcr;
        this.template = template;
        this.elementsLoaderService = elementsLoaderService;
        this.cfr = cfr;
        this.cdr = cdr;
        // tslint:disable-line:no-input-rename
        this.viewRef = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const tpl = (/** @type {?} */ (this.template));
        /** @type {?} */
        const elementTag = tpl._declarationTContainer
            ? tpl._declarationTContainer.tagName
            : tpl._def.element.template.nodes[0].element.name;
        /** @type {?} */
        const elementConfig = this.elementsLoaderService.getElementConfig(elementTag) ||
            ((/** @type {?} */ ({})));
        /** @type {?} */
        const options = this.elementsLoaderService.options;
        /** @type {?} */
        const loadingComponent = elementConfig.loadingComponent || options.loadingComponent;
        if (this.loadingTemplateRef) {
            this.vcr.createEmbeddedView(this.loadingTemplateRef);
        }
        else if (loadingComponent) {
            /** @type {?} */
            const factory = this.cfr.resolveComponentFactory(loadingComponent);
            this.vcr.createComponent(factory);
        }
        this.elementsLoaderService
            .loadElement(this.url, elementTag, this.isModule, this.importMap, elementConfig === null || elementConfig === void 0 ? void 0 : elementConfig.hooks)
            .then((/**
         * @return {?}
         */
        () => customElements.whenDefined(elementTag)))
            .then((/**
         * @return {?}
         */
        () => {
            this.vcr.clear();
            this.viewRef = this.vcr.createEmbeddedView(this.template);
            this.cdr.markForCheck();
        }))
            .catch((/**
         * @return {?}
         */
        () => {
            this.vcr.clear();
            /** @type {?} */
            const errorComponent = elementConfig.errorComponent || options.errorComponent;
            if (this.errorTemplateRef) {
                this.vcr.createEmbeddedView(this.errorTemplateRef);
                this.cdr.markForCheck();
            }
            else if (errorComponent) {
                /** @type {?} */
                const factory = this.cfr.resolveComponentFactory(errorComponent);
                this.vcr.createComponent(factory);
                this.cdr.markForCheck();
            }
            else {
                console.error(`${LOG_PREFIX$1} - Loading of element <${elementTag}> failed, please provide <ng-template #error>Loading failed...</ng-template> and reference it in *axLazyElement="errorTemplate: error" to display customized error message in place of element`);
            }
        }));
    }
    /**
     * @return {?}
     */
    destroyEmbeddedView() {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.detach();
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
LazyElementDirective.decorators = [
    { type: Directive, args: [{
                selector: '[axLazyElement]',
            },] }
];
/** @nocollapse */
LazyElementDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: LazyElementsLoaderService },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef }
];
LazyElementDirective.propDecorators = {
    url: [{ type: Input, args: ['axLazyElement',] }],
    loadingTemplateRef: [{ type: Input, args: ['axLazyElementLoadingTemplate',] }],
    errorTemplateRef: [{ type: Input, args: ['axLazyElementErrorTemplate',] }],
    isModule: [{ type: Input, args: ['axLazyElementModule',] }],
    importMap: [{ type: Input, args: ['axLazyElementImportMap',] }]
};
if (false) {
    /** @type {?} */
    LazyElementDirective.prototype.url;
    /** @type {?} */
    LazyElementDirective.prototype.loadingTemplateRef;
    /** @type {?} */
    LazyElementDirective.prototype.errorTemplateRef;
    /** @type {?} */
    LazyElementDirective.prototype.isModule;
    /** @type {?} */
    LazyElementDirective.prototype.importMap;
    /**
     * @type {?}
     * @private
     */
    LazyElementDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    LazyElementDirective.prototype.vcr;
    /**
     * @type {?}
     * @private
     */
    LazyElementDirective.prototype.template;
    /**
     * @type {?}
     * @private
     */
    LazyElementDirective.prototype.elementsLoaderService;
    /**
     * @type {?}
     * @private
     */
    LazyElementDirective.prototype.cfr;
    /**
     * @type {?}
     * @private
     */
    LazyElementDirective.prototype.cdr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/lazy-elements/lazy-element-dynamic/lazy-element-dynamic.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOG_PREFIX$2 = '@angular-extensions/elements';
/**
 * \@dynamic
 */
class LazyElementDynamicDirective {
    /**
     * @param {?} document
     * @param {?} renderer
     * @param {?} vcr
     * @param {?} cfr
     * @param {?} cdr
     * @param {?} template
     * @param {?} elementsLoaderService
     */
    constructor(document, renderer, vcr, cfr, cdr, template, elementsLoaderService) {
        this.document = document;
        this.renderer = renderer;
        this.vcr = vcr;
        this.cfr = cfr;
        this.cdr = cdr;
        this.template = template;
        this.elementsLoaderService = elementsLoaderService;
        // tslint:disable-line:no-input-rename
        this.viewRef = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.tag || this.tag.length === 0 || !this.tag.includes('-')) {
            throw new Error(`${LOG_PREFIX$2} - Valid tag has to be specified when using *axLazyElementDynamic directive (use *axLazyElementDynamic="'some-tag'"), got: "${this.tag}"`);
        }
        /** @type {?} */
        const elementConfig = this.elementsLoaderService.getElementConfig(this.tag) ||
            ((/** @type {?} */ ({})));
        /** @type {?} */
        const options = this.elementsLoaderService.options;
        /** @type {?} */
        const loadingComponent = elementConfig.loadingComponent || options.loadingComponent;
        if (this.loadingTemplateRef) {
            this.vcr.createEmbeddedView(this.loadingTemplateRef);
        }
        else if (loadingComponent) {
            /** @type {?} */
            const factory = this.cfr.resolveComponentFactory(loadingComponent);
            this.vcr.createComponent(factory);
        }
        this.elementsLoaderService
            .loadElement(this.url, this.tag, this.isModule, this.importMap, elementConfig === null || elementConfig === void 0 ? void 0 : elementConfig.hooks)
            .then((/**
         * @return {?}
         */
        () => customElements.whenDefined(this.tag)))
            .then((/**
         * @return {?}
         */
        () => {
            this.vcr.clear();
            /** @type {?} */
            const originalCreateElement = this.renderer.createElement;
            this.renderer.createElement = (/**
             * @param {?} name
             * @param {?} namespace
             * @return {?}
             */
            (name, namespace) => {
                if (name === 'ax-lazy-element') {
                    name = this.tag;
                }
                return this.document.createElement(name);
            });
            this.viewRef = this.vcr.createEmbeddedView(this.template);
            this.renderer.createElement = originalCreateElement;
            this.cdr.markForCheck();
        }))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            /** @type {?} */
            const errorComponent = elementConfig.errorComponent || options.errorComponent;
            this.vcr.clear();
            if (this.errorTemplateRef) {
                this.vcr.createEmbeddedView(this.errorTemplateRef);
                this.cdr.markForCheck();
            }
            else if (errorComponent) {
                /** @type {?} */
                const factory = this.cfr.resolveComponentFactory(errorComponent);
                this.vcr.createComponent(factory);
                this.cdr.markForCheck();
            }
            else {
                console.error(`${LOG_PREFIX$2} - Loading of element <${this.tag}> failed, please provide <ng-template #error>Loading failed...</ng-template> and reference it in *axLazyElementDynamic="errorTemplate: error" to display customized error message in place of element\n\n`, error);
            }
        }));
    }
    /**
     * @return {?}
     */
    destroyEmbeddedView() {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.detach();
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
LazyElementDynamicDirective.decorators = [
    { type: Directive, args: [{
                selector: '[axLazyElementDynamic]',
            },] }
];
/** @nocollapse */
LazyElementDynamicDirective.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: TemplateRef },
    { type: LazyElementsLoaderService }
];
LazyElementDynamicDirective.propDecorators = {
    tag: [{ type: Input, args: ['axLazyElementDynamic',] }],
    url: [{ type: Input, args: ['axLazyElementDynamicUrl',] }],
    loadingTemplateRef: [{ type: Input, args: ['axLazyElementDynamicLoadingTemplate',] }],
    errorTemplateRef: [{ type: Input, args: ['axLazyElementDynamicErrorTemplate',] }],
    isModule: [{ type: Input, args: ['axLazyElementDynamicModule',] }],
    importMap: [{ type: Input, args: ['axLazyElementDynamicImportMap',] }]
};
if (false) {
    /** @type {?} */
    LazyElementDynamicDirective.prototype.tag;
    /** @type {?} */
    LazyElementDynamicDirective.prototype.url;
    /** @type {?} */
    LazyElementDynamicDirective.prototype.loadingTemplateRef;
    /** @type {?} */
    LazyElementDynamicDirective.prototype.errorTemplateRef;
    /** @type {?} */
    LazyElementDynamicDirective.prototype.isModule;
    /** @type {?} */
    LazyElementDynamicDirective.prototype.importMap;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.document;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.vcr;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.cfr;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.cdr;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.template;
    /**
     * @type {?}
     * @private
     */
    LazyElementDynamicDirective.prototype.elementsLoaderService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/lazy-elements/lazy-elements.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} rootOptions
 * @return {?}
 */
function createLazyElementRootGuard(rootOptions) {
    if (rootOptions) {
        throw new TypeError(`LazyElementsModule.forRoot() called twice. Feature modules should use LazyElementsModule.forFeature() instead.`);
    }
    return 'LazyElementsModule.forRoot() multiple execution guard';
}
class LazyElementsModule {
    /**
     * @param {?} lazyElementsLoaderService
     * @param {?} elementConfigsMultiProvider
     * @param {?} guard
     */
    constructor(lazyElementsLoaderService, elementConfigsMultiProvider, guard) {
        if (elementConfigsMultiProvider && elementConfigsMultiProvider.length) {
            elementConfigsMultiProvider
                .filter((/**
             * @param {?} configs
             * @return {?}
             */
            (configs) => configs.some((/**
             * @param {?} config
             * @return {?}
             */
            (config) => !config.isAdded))))
                .forEach((/**
             * @param {?} configs
             * @return {?}
             */
            (configs) => lazyElementsLoaderService.addConfigs(configs)));
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static forRoot(options) {
        return {
            ngModule: LazyElementsModule,
            providers: [
                {
                    provide: LAZY_ELEMENT_CONFIGS,
                    useValue: options && options.elementConfigs ? options.elementConfigs : [],
                    multi: true,
                },
                {
                    provide: LAZY_ELEMENT_ROOT_OPTIONS,
                    useValue: options.rootOptions ? options.rootOptions : {},
                },
                {
                    provide: LAZY_ELEMENT_ROOT_GUARD,
                    useFactory: createLazyElementRootGuard,
                    deps: [[LAZY_ELEMENT_ROOT_OPTIONS, new Optional(), new SkipSelf()]],
                },
            ],
        };
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static forFeature(options) {
        return {
            ngModule: LazyElementsModule,
            providers: [
                {
                    provide: LAZY_ELEMENT_CONFIGS,
                    useValue: options && options.elementConfigs ? options.elementConfigs : [],
                    multi: true,
                },
            ],
        };
    }
}
LazyElementsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [LazyElementDirective, LazyElementDynamicDirective],
                imports: [CommonModule],
                exports: [LazyElementDirective, LazyElementDynamicDirective],
                providers: [],
            },] }
];
/** @nocollapse */
LazyElementsModule.ctorParameters = () => [
    { type: LazyElementsLoaderService },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [LAZY_ELEMENT_CONFIGS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LAZY_ELEMENT_ROOT_GUARD,] }] }
];
/**
 * @record
 */
function LazyElementModuleOptions() { }
if (false) {
    /** @type {?|undefined} */
    LazyElementModuleOptions.prototype.elementConfigs;
}
/**
 * @record
 */
function LazyElementModuleRootOptions() { }
if (false) {
    /** @type {?|undefined} */
    LazyElementModuleRootOptions.prototype.elementConfigs;
    /** @type {?|undefined} */
    LazyElementModuleRootOptions.prototype.rootOptions;
}
/**
 * @record
 */
function LazyElementRootOptions() { }
if (false) {
    /** @type {?|undefined} */
    LazyElementRootOptions.prototype.loadingComponent;
    /** @type {?|undefined} */
    LazyElementRootOptions.prototype.errorComponent;
    /** @type {?|undefined} */
    LazyElementRootOptions.prototype.isModule;
    /** @type {?|undefined} */
    LazyElementRootOptions.prototype.importMap;
    /** @type {?|undefined} */
    LazyElementRootOptions.prototype.preload;
    /** @type {?|undefined} */
    LazyElementRootOptions.prototype.hooks;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: angular-extensions-elements.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { LAZY_ELEMENTS_REGISTRY, LAZY_ELEMENT_CONFIGS, LAZY_ELEMENT_ROOT_GUARD, LAZY_ELEMENT_ROOT_OPTIONS, LazyElementDirective, LazyElementDynamicDirective, LazyElementsLoaderService, LazyElementsModule, createLazyElementRootGuard };
//# sourceMappingURL=angular-extensions-elements.js.map
